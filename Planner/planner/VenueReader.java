package planner;

import java.io.*;
import java.util.*;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * Provides a method to read in a list of venues from a text file.
 */
public class VenueReader {

    // definition of an empty line
    private final static String EMPTY_LINE = "";

    /**
     * <p>
     * Reads a text file called fileName that describes the venues in a
     * municipality, and returns a list containing each of the venues read from
     * the file, in the order that they appear in the file.
     * </p>
     * 
     * <p>
     * The file contains zero or more descriptions of different venues. (I.e. a
     * file containing zero venues contains zero lines; a file containing one
     * venue contains exactly one description of a venue and no other lines or
     * information; a file containing multiple venues contains each description
     * of a venue, one after the other with no other information or lines in the
     * file.)
     * </p>
     * 
     * <p>
     * A description of a venue consists of exactly (i) one line consisting of
     * the name of the venue followed by (ii) one line containing a positive
     * integer denoting the capacity of the venue followed by (iii) a
     * description of the traffic generated by hosting an event of maximum size
     * at the venue, followed by (iv) an empty line.
     * </p>
     * 
     * <p>
     * For (i) the venue name is the entire string on the first line of the
     * venue description (i.e. it may contain white space characters etc.). The
     * only constraint on the venue name is that it may not be equal to the
     * empty string ("").
     * </p>
     * 
     * <p>
     * For (ii) the second line of a venue description may not contain leading
     * or trailing whitespace characters, it may only contain a positive integer
     * denoting the venue capacity.
     * </p>
     * 
     * <p>
     * For (iii) the traffic is described by one line for each corridor that
     * will have traffic from the venue when it hosts an event of maximum size.
     * Each line is a string of the form <br>
     * <br>
     * "START, END, CAPACITY: TRAFFIC"<br>
     * <br>
     * where START and END are different non-empty strings denoting the name of
     * the start location of the corridor and the end location of the corridor,
     * respectively; CAPACITY is a positive integer denoting the capacity of the
     * corridor; and TRAFFIC is a positive integer denoting the amount of
     * traffic from the venue that will use the corridor when the venue hosts
     * the largest event that it can. The strings denoting the start and end
     * locations of the corridor may contain any characters other than a comma
     * (',') or semicolon (':'). Both CAPACITY and TRAFFIC should be positive
     * integers with no additional leading or trailing whitespace. For example,
     * <br>
     * <br>
     * "St. Lucia, Royal Queensland Show - EKKA, 120: 60"<br>
     * <br>
     * represents a traffic corridor from "St. Lucia" to "Royal Queensland Show
     * - EKKA" with a maximum capacity of 120, that will have 60 people from the
     * venue using it when the venue hosts an event of maximum size. <br>
     * <br>
     * Note that the start, end and capacity of a corridor are separated by the
     * string ", ". The corridor and its traffic are separated by ": ". <br>
     * <br>
     * The corridors and their respective traffic may appear in any order (i.e.
     * the corridors aren't necessarily sorted in any way.) Each corridor may
     * only appear once in the traffic description for a venue (i.e. there is
     * only one line for each corridor), and the traffic on that corridor should
     * be less than or equal to the capacity of the venue, and less than or
     * equal to the capacity of the corridor.
     * </p>
     * 
     * <p>
     * For (iv) an empty line is a line with no characters at all (i.e. the
     * contents of the line is the empty string "").
     * </p>
     * 
     * <p>
     * Two equivalent venues shouldn't appear twice in the file.
     * </p>
     * 
     * <p>
     * If a FormatException is thrown, it will have a meaningful message that
     * accurately describes the problem with the input file format, including
     * the line of the file where the problem was detected.
     * </p>
     * 
     * @param fileName
     *            the name of the file to read from.
     * @return a list of the venues from the file, in the order in which they
     *         appear in the file.
     * @throws IOException
     *             if there is an error reading from the input file.
     * @throws FormatException
     *             if there is an error with the input format (e.g. there is
     *             more than one venue description in the file that describes
     *             the same venue, or the file format is not as specified above
     *             in any other way.) The FormatExceptions thrown should have a
     *             meaningful message that accurately describes the problem with
     *             the input file format, including the line of the file where
     *             the problem was detected.
     */
    public static List<Venue> read(String fileName) throws IOException,
            FormatException {
        // scanner for reading the file a line at a time
        Scanner in = new Scanner(new FileReader(fileName));
        // the number of the line being read
        AtomicInteger lineNumber = new AtomicInteger(0);
        // the venues that will be read from the file
        List<Venue> venues = new ArrayList<>();

        // read venues one at a time from the file
        while (in.hasNextLine()) {
            // the name, capacity, and traffic of the venue being read
            String name = readVenueName(lineNumber, in);
            int capacity = readVenueCapacity(lineNumber, in);
            Traffic capacityTraffic = readTraffic(lineNumber, in, capacity);
            // the venue read
            Venue venue = new Venue(name, capacity, capacityTraffic);

            if (venues.contains(venue)) {
                throw new FormatException("Line " + lineNumber
                        + ": duplicate venue detected.");
            }
            venues.add(venue);
        }
        return venues;
    }

    /**
     * Consumes the next line from the scanner, returning the venue name read
     * from that line.
     * 
     * @require in!=null && in is open for reading
     * @ensure Consumes the next line from scanner, and returns the venue name
     *         from that line (i.e. the whole line). The lineNumber is
     *         incremented once for each line that is consumed from in.
     * @throws FormatException
     *             if there is no next line in the scanner, or the line is the
     *             empty string "" (i.e. a venue name can't be the empty
     *             string). The exception has a message that identifies the
     *             lineNumber given, and describes the nature of the error.
     */
    private static String readVenueName(AtomicInteger lineNumber, Scanner in)
            throws FormatException {
        // the name of the venue to be read from the next line
        String name = null;
        if (in.hasNextLine()) {
            name = in.nextLine();
            lineNumber.incrementAndGet();
        } else {
            throw new FormatException("Line " + lineNumber
                    + ": venue name missing");
        }
        if (name.equals("")) {
            throw new FormatException("Line " + lineNumber
                    + ": venue name cannot be the empty string");
        }
        return name;
    }

    /**
     * Consumes the next line from the scanner, returning the venue capacity
     * read from that line.
     * 
     * @require in!=null && in is open for reading
     * @ensure reads next line from scanner, and returns the venue capacity from
     *         that line. The lineNumber is incremented once for each line that
     *         is consumed from in.
     * @throws FormatException
     *             if there is no next line in the scanner, or the line does not
     *             contain one positive integer denoting the venue capacity. The
     *             exception has a message that identifies the lineNumber given,
     *             and describes the nature of the error.
     */
    private static int readVenueCapacity(AtomicInteger lineNumber, Scanner in)
            throws FormatException {
        if (!in.hasNextLine()) {
            throw new FormatException("Line " + lineNumber
                    + ": venue capacity expected, but line is missing.");
        }

        // the capacity to be read the next line from the scanner
        int capacity = 0;
        try {
            // the line holding the capacity
            String capacityString = in.nextLine();
            lineNumber.incrementAndGet();
            capacity = Integer.parseInt(capacityString);
        } catch (NumberFormatException e) {
            throw new FormatException("Line " + lineNumber
                    + ": invalid venue capacity.");
        }
        if (capacity <= 0) {
            throw new FormatException("Line " + lineNumber
                    + ": capacity must be greater than or equal to zero.");
        }
        return capacity;
    }

    /**
     * Consumes zero or more lines from the scanner, where each line denotes a
     * corridor object and its traffic, until an empty line is consumed. Returns
     * a traffic object containing the traffic read from each of the lines. Each
     * of the traffic lines is of the form "START, END, CAPACITY: TRAFFIC" (e.g.
     * "l0, l1, 100: 50").
     *
     * @require in!=null && in is open for reading
     * @ensure Consumes zero or more lines from the scanner, each denoting the
     *         amount of traffic on different corridors, until an empty line is
     *         consumed, and returns the traffic read from those lines. The
     *         lineNumber is incremented once for each line that is consumed
     *         from the scanner in.
     * @throws FormatException
     *             If any one of the traffic lines read are incorrectly
     *             formatted; if the end of the scanner is reached before an
     *             empty line is found; if the same corridor appears in more
     *             than one line; or if the traffic on a corridor exceeds the
     *             venue capacity given, or its capacity. The exception has a
     *             message that identifies the lineNumber given, and describes
     *             the nature of the error.
     */
    private static Traffic readTraffic(AtomicInteger lineNumber, Scanner in,
            int venueCapacity) throws FormatException {
        // the traffic read from the scanner
        Traffic capacityTraffic = new Traffic();
        // the current line being read
        String line = getNextLine(lineNumber, in);
        while (!line.equals(EMPTY_LINE)) {
            // scanner for that line
            Scanner lineScanner = new Scanner(line);
            lineScanner.useDelimiter(": ");
            try {
                // e.g. "l0, l1, 100: 50"
                Corridor corridor = readCorridor(lineNumber, lineScanner);
                int amount = readTraffic(lineNumber, lineScanner, corridor
                        .getCapacity(), venueCapacity);

                if (lineScanner.hasNext()) {
                    throw new FormatException("Line " + lineNumber
                            + ": extra information on line.");
                }
                if (capacityTraffic.getTraffic(corridor) > 0) {
                    throw new FormatException("Line " + lineNumber
                            + ": corridor appears more than once.");
                }
                capacityTraffic.updateTraffic(corridor, amount);
            } finally {
                lineScanner.close();
            }
            line = getNextLine(lineNumber, in); // read the next line
        }
        return capacityTraffic;
    }

    /**
     * Consumes and returns the next line from the given scanner.
     *
     * @require in!=null && in is open for reading
     * @ensure Consumes and returns the next line from the given scanner. The
     *         lineNumber is incremented once for each line that is consumed
     *         from in.
     * @throws FormatException
     *             If there is no next line to read from the input. The
     *             exception has a message that identifies the lineNumber given,
     *             and describes the nature of the error.
     */
    private static String getNextLine(AtomicInteger lineNumber, Scanner in)
            throws FormatException {
        String line = null;
        if (in.hasNextLine()) {
            line = in.nextLine();
            lineNumber.incrementAndGet();
        } else {
            throw new FormatException("Line " + lineNumber
                    + ": empty line expected to complete venue.");
        }
        return line;
    }

    /**
     * Consumes the next token from the lineScanner, and returns the associated
     * corridor object. The token denoting the corridor should be of the form
     * "START, END, CAPACITY" (e.g. "l0, l1, 100").
     * 
     * @require lineScanner!=null && lineScanner is open for reading
     * @ensure Consumes the next token from the lineScanner and returns the
     *         corridor represented by that token. lineNumber is unchanged by
     *         this operation.
     * @throws FormatException
     *             If lineScanner doesn't have a next token, or if the corridor
     *             is incorrectly formatted. The exception has a message that
     *             identifies the lineNumber given, and describes the nature of
     *             the error.
     */
    private static Corridor readCorridor(AtomicInteger lineNumber,
            Scanner lineScanner) throws FormatException {
        if (!lineScanner.hasNext()) {
            throw new FormatException("Line " + lineNumber
                    + ": invalid corridor and traffic");
        }
        // Comma-delimited scanner for reading the corridor
        Scanner scanner = new Scanner(lineScanner.next());
        scanner.useDelimiter(", ");
        try {
            String startName = (scanner.hasNext() ? scanner.next() : "");
            String endName = (scanner.hasNext() ? scanner.next() : "");
            int capacity = (scanner.hasNextInt() ? scanner.nextInt() : 0);

            if (startName.equals("") || endName.equals("") || capacity <= 0
                    || startName.equals(endName) || scanner.hasNext()
                    || startName.contains(":") || endName.contains(":")
                    || startName.contains(",") || endName.contains(",")) {
                throw new FormatException("Line " + lineNumber
                        + ": invalid corridor.");
            }
            return new Corridor(new Location(startName), new Location(endName),
                    capacity);
        } finally {
            scanner.close();
        }
    }

    /**
     * Consumes the next token from the lineScanner, and returns the amount of
     * traffic (an integer) read from that token. The token denoting the amount
     * of traffic should be a single integer greater than zero and less than or
     * equal to corridorCapacity and the venueCapacity, with no proceeding or
     * trailing white space.
     * 
     * @require lineScanner!=null && lineScanner is open for reading
     * @ensure Consumes the next token from the lineScanner and returns the
     *         amount of traffic represented by that token. lineNumber is
     *         unchanged by this operation.
     * @throws FormatException
     *             If lineScanner doesn't have a next token, or if the token
     *             corresponding to the amount of traffic is incorrectly
     *             formatted, or out of bounds. The exception has a message that
     *             identifies the lineNumber given, and describes the nature of
     *             the error.
     */
    private static int readTraffic(AtomicInteger lineNumber,
            Scanner lineScanner, int corridorCapacity, int venueCapacity)
            throws FormatException {
        // the amount of traffic read from the next token
        if (!lineScanner.hasNextInt()) {
            throw new FormatException("Line " + lineNumber
                    + ": traffic is missing or incorrectly formatted.");
        }
        int amount = lineScanner.nextInt();
        if (amount <= 0) {
            throw new FormatException("Line " + lineNumber
                    + ": traffic is less than or equal to zero.");
        }
        if (amount > corridorCapacity) {
            throw new FormatException("Line " + lineNumber
                    + ": traffic exceeds the corridor capacity.");

        }
        if (amount > venueCapacity) {
            throw new FormatException("Line " + lineNumber
                    + ": traffic exceeds either the venue capacity.");

        }
        return amount;
    }

}
